# 多线程实战
## 创建启动运行
一个线程就是一个对象，对象的创建离不开内在空间的分配。创建线程对象与创建其他类型的对象所不同的是，Java虚拟机会为每个线程分配调用栈(Call Stack)所需的内存空间。另外，每个线程可能还有一个内核线程与之对应。因此，创建线程比创建其他对象成本要高。

## 两种创建线程方式
Thread类实际上是Runnable接口的一个实现类，其对Runnable接口的实现如下。其中target就是通过构造函数传进来的Runnable实例。因此，Thread类所实现的任务处理逻辑是要么什么也不做，要么直接执行target所引用的Runnable实例所实现的任务处理逻辑。而以定义Thread类子类的方式是通过覆盖父类run方法实现。
```java
public void run() {
    if(target != null) {
        target.run();
    }
}
```
## 区别
1. 子类方式是基于继承的。Runnable方式是基于组合的。一般认为组合相对耦合性更低，因此更加灵活，是优先选用的技术。
2. Runnable方式意味着多个线程实例可以共享同一个Runnable实例。在某些情况下会出现竞态和线程安全的问题。
3. Java中的线程(Thread)实例是一个特殊的Runnable实例，创建时会分配调用栈空间，内核线程等资源。因此，创建线程实例比普通的Runnable实例成本要昂贵一点。一般创建Runnable实例再将其作为方法参数传给其他对象使用。
## 线程的属性
|      属性       |                                  类型及用途                                  | 只读 |                                                                             注意事项                                                                              |
| --------------- | --------------------------------------------------------------------------- | --- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| ID              | long 标识不同线程，不同线程拥有不同编号                                         | 是   | 某个编号的线程运行结束后，该编号可能被后续使用。编号的唯一性只在虚拟机的一次运行有效。也就是说重启后，编号可能与上次运行的某个编号相同，因此编号不适合作唯一标识，特别是数据库的主键 |
| Name            | String 面向人的一个属性，用于区分不同线程。默认格式为:Thread-线程编号             | 否   | 并不禁止设置相同的线程名                                                                                                                                            |
| Daemon(类别)     | boolean 值true表示为守护线程，false表示用户线程。默认值与父线程的相同             | 否   | 该属性必须在启动之前设置，否则会抛出IllegalThreadStateException异常。负责关键任务的线程不适宜设置为守护                                                                   |
| 优先级(Priority) | int 表示哪个线程能够优先得以运行。共1~10个级别。默认值5表示普通优先级。默认与父相同 | 否   | 一般使用默认级即可。不恰当地设置可能导致严重问题(线程饥饿)                                                                                                             |
1. 线程优先级本质是一个给线程调度器的提示信息，以便线程调度器决定优先调度哪些线程运行。它并不保证线程按照优先级高低顺序执行。注意，使用不当或者滥用可能导致某些线程永远无法执行，即线程饥饿(Thread Starvation)。因此不是越高越好。使用默认级，即不必设置
2. 按照线程是否会阻止虚拟机正常停止，可以分为守护线程和用户线程。用户线程会阻止虚拟机正常停止，即一个虚拟机只有在所有用户线程都运行结束的情况下才能正常停止。而守护线程则不会影响虚拟机的正常停止，即有守护线程在运行也不影响虚拟机的正常停止。因此守护线程通常用于执行一些重要性不高的任务，例如用于监视其他线程的运行情况。
## 线程的常用方法
| 方法  |                        功能                        |                           备注                           |
| ---- | -------------------------------------------------- | -------------------------------------------------------- |
| join | 等待相应线程运行结束                                 | 若线程A调用线程B的join方法，那么A的运行会被暂停，直到B运行结束 |
| yield | 使当前线程主动放弃对处理器的占用，这可能导致当前线程暂停 | 这个方法是不可靠的。可能仍然继续运行                         |
| sleep | 使当前线程休眠(暂停运行)指定的时间                    |                                                          |
1. join 我先暂停一下，等到另外一个线程运行结束后我才能继续。
2. yield 我现在不急，如果别人需要处理器先给他用吧。当然如果没有其他人用，我也不介意继续占用。
3. sleep 我休息一会，过段时间再叫醒我继续干活吧。
## 废弃方法
在写代码中应该避免使用如下方法.
|  方法   |        功能        |
| ------- | ------------------ |
| stop    | 停止线程的运行      |
| suspend | 暂停线程的运行      |
| resume  | 使暂停的线程继续运行 |
## 线程的层次关系
在多线程编程中，弄清楚一段代码具体是由哪个线程去负责执行很重要。